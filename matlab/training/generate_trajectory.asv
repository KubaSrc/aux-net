close all; clc; clear all;

home_pos = load('../training/state/home_measured.mat').pos;
point_density = load('../training/state/point_density.mat').dist_per_point;

%% First trajectory (circle)

tool_rot = eye(3);
tool_quat = rotm2quat(tool_rot);

n = 20;
r = 80;
theta = linspace(0,2*pi,n).';

x_c = r.*cos(theta);
y_c = r.*sin(theta);
z_c = repmat(10,size(theta));

wp = [zeros(1,3), tool_quat;
      x_c, y_c, z_c, repmat(tool_quat,[n,1])];
wp = wp + home_pos;
wp = interp_waypoints(wp,point_density);

figure(1); clf; hold on; grid on

plot3(wp(:,1), wp(:,2), wp(:,3), 'k:', 'LineWidth', 1.5); % 'k:' makes the line black and dotted, 'LineWidth' sets the thickness

xlabel('X-axis'); % Label for the x-axis
ylabel('Y-axis'); % Label for the y-axis
zlabel('Z-axis'); % Label for the z-axis

title('3D Line Plot with Grid'); % Title for the plot

%% Second trajectory (steps)

%% Third trajectory (orthongal line)

%% Helper functions

function interpolatedWaypoints = interp_waypoints(waypoints, totalPoints)
    % Extract the Euclidean and quaternion parts from the waypoints
    positions = waypoints(:, 1:3);
    quaternions = waypoints(:, 4:7); % Directly use quaternions as given
    
    % Calculate the total path length and segment lengths
    numSegments = size(waypoints, 1) - 1;
    segmentLengths = zeros(numSegments, 1);
    for i = 1:numSegments
        segmentLengths(i) = norm(positions(i+1, :) - positions(i, :));
    end
    totalLength = sum(segmentLengths);
    
    % Determine the number of points per segment based on their proportion of the total length
    segmentPoints = max(2, round((segmentLengths / totalLength) * totalPoints));
    
    % Ensure that the sum of segment points matches the total points specified
    while sum(segmentPoints) < totalPoints
        [minValue, minIndex] = min(segmentPoints);
        segmentPoints(minIndex) = segmentPoints(minIndex) + 1;
    end
    while sum(segmentPoints) > totalPoints
        [maxValue, maxIndex] = max(segmentPoints);
        segmentPoints(maxIndex) = segmentPoints(maxIndex) - 1;
    end
    
    % Initialize variables for interpolated waypoints
    interpolatedPositions = [];
    interpolatedQuaternions = [];
    
    % Perform interpolation over the entire set
    currentIdx = 1; % Keep track of the current index for interpolation
    for i = 1:numSegments
        % Calculate interpolation fractions for this segment
        tSegment = linspace(0, 1, segmentPoints(i));
        
        % Interpolate positions using cubic spline
        splineCoeff = spline([0, 1], positions(i:i+1, :)');
        tempPositions = ppval(splineCoeff, tSegment)';
        
        % Normalize quaternions before interpolation
        qStart = quaternions(i, :) / norm(quaternions(i, :));
        qEnd = quaternions(i+1, :) / norm(quaternions(i+1, :));
        
        % Interpolate quaternions
        interpolatedQ = zeros(segmentPoints(i), 4); % Pre-allocate for speed
        for j = 1:segmentPoints(i)
            t = (j-1) / (segmentPoints(i)-1);
            interpolatedQ(j, :) = quatinterp(qStart, qEnd, t, 'slerp');
        end
        
        % Append interpolated positions and quaternions, avoid duplicating the end point
        if i == numSegments
            interpolatedPositions = [interpolatedPositions; tempPositions];
            interpolatedQuaternions = [interpolatedQuaternions; interpolatedQ];
        else
            interpolatedPositions = [interpolatedPositions; tempPositions(1:end-1, :)];
            interpolatedQuaternions = [interpolatedQuaternions; interpolatedQ(1:end-1, :)];
        end
    end
    
    % Combine interpolated positions and quaternions
    interpolatedWaypoints = [interpolatedPositions, interpolatedQuaternions];
end


% function interpolatedWaypoints = interp_waypoints(waypoints, pointsPerUnitDistance)
%     % Extract the Euclidean and quaternion parts from the waypoints
%     positions = waypoints(:, 1:3);
%     % Reorder quaternions from [qx qy qz qw] to [qw qx qy qz] for MATLAB compatibility
%     quaternions = waypoints(:, 4:7);
% 
%     % Initialize variables for interpolated waypoints
%     interpolatedPositions = [];
%     interpolatedQuaternions = [];
% 
%     % Loop through each pair of waypoints
%     for i = 1:size(waypoints, 1) - 1
%         % Calculate distance between waypoints
%         dist = norm(positions(i+1, :) - positions(i, :));
% 
%         % Calculate the number of points to interpolate
%         numPoints = max(2, round(dist * pointsPerUnitDistance));
% 
%         % Interpolate positions using cubic spline
%         t = linspace(0, 1, numPoints);
%         tempPositions = zeros(numPoints, 3); % Temporary storage for interpolated positions
% 
%         for dim = 1:3
%             splineCoeff = spline([0, 1], [positions(i, dim), positions(i+1, dim)]);
%             tempPositions(:, dim) = ppval(splineCoeff, t);
%         end
% 
%         % Append this segment's interpolated positions
%         interpolatedPositions = [interpolatedPositions; tempPositions];
% 
%         % Normalize quaternions before interpolation
%         qStart = quaternions(i, :) / norm(quaternions(i, :));
%         qEnd = quaternions(i+1, :) / norm(quaternions(i+1, :));
% 
%         % Interpolate quaternions
%         interpolatedQ = zeros(numPoints, 4); % Pre-allocate for speed
%         for j = 1:numPoints
%             t = (j-1) / (numPoints-1);
%             interpolatedQ(j, :) = quatinterp(qStart, qEnd, t, 'slerp');
%         end
% 
%         % Append interpolated quaternions, reorder back to [qx qy qz qw]
%         interpolatedQuaternions = [interpolatedQuaternions; interpolatedQ];
%     end
% 
%     % Combine interpolated positions and reordered quaternions
%     interpolatedWaypoints = [interpolatedPositions, interpolatedQuaternions];
% end

